## 一条更新 sql 语句的执行过程

一条更新 sql 语句的执行过程，有两个非常关键的日志模块 `binlog` 和 `redolog`

mysql 在写日志的时候,是记录 **前日志**,也就是说在真正执行语句之前,就已经写好日志了

具体来说,当有一条记录需要更新时,先在 `redolog` 里面写好日志,并更新内存,此时就返回记录已经更新。

而在随后的某个合适的时机,mysql 会将 `redolog` 里面的记录写入磁盘完成持久化。

### redolog

![](./pic/Snipaste_2023-05-12_22-15-41.png)

`redolog` 的写入是循环写的,当前正在写的最新位置记为 `write pos` 而当前需要刷入磁盘持久化的位置记为 `checkpoint`

如果 `write pos` 追上了 `checkpoint` 则表明此时新写入的数据速度超过 mysql 刷盘持久化的速度,此时 mysql 将暂时停止新数据的写入,而是进行刷盘持久化推进 `checkpoint` 的位置

`redolog` 所处的位置是 **存储引擎** 而且是 `InnoDB` 独有的日志系统

### binlog

对于 mysql 本身来说如果不使用 `InnoDB` 也就无法使用 `redolog` 所以 mysql 自己还需要维护一份与存储引擎无关的日志系统,也就是 `binlog`

#### binlog 和 redolog 的不同

1. `redolog` 是 `InnoDB` 独有的日志系统,其他存储引擎没有
2. `binlog` 是 mysql 自己的日志系统,所有的存储引擎都能使用
3. `redolog` 记录的是物理日志,也就是 **在某个数据页上做了某某修改**; 而 `binlog` 记录的是逻辑日志,也就是 **给 id = x 的 y 字段修改为 z**
4. `redolog` 是循环写的,有固定的大小空间,可能会因为新数据写入速度快于刷盘速度导致 `redolog` 被写满; 而 `binlog` 理论上是可以一直追加写入的,达到一个 `binlog` 日志文件的大小后就会写入新的日志文件,并不会覆盖以前的记录


### 一条更新语句的实际执行细节

1. 执行器通过索引树检索到 `id=x` 的记录. 如果存储引擎的内存缓存里有这行数据,则直接返回; 否则先从磁盘中加载记录所在的页到内存里,再返回
2. 执行器拿到引擎返回的数据后,对 `id=x` 的数据进行更新操作得到新数据,再把新数据提交到存储引擎
3. 存储引擎在拿到新数据后,先在 `redolog` 里面记录下对应的操作,接着把新数据更新到内存里,然后通知执行器可以提交事务,此时 `redolog` 里面记录的状态是 `prepare`
4. 执行器收到存储引擎返回写入成功的通知后,写入 `binlog` 日志,并刷盘持久化 `binlog` 
5. 执行器提交事务,存储引擎将 `redolog` 的日志状态修改为 `commit`,此时整个 sql 语句的更新才算完成

### 两阶段提交协议

可以看到,一行更新 sql 在实际执行的过程当中, `redolog` 经历了两次写入

1. 一次是存储引擎写入 `redolog` 的 `prepare` 状态
2. 第二次是执行器写入 `binlog` 后,存储引擎继续更新 `redolog` 的 `commit` 状态

而数据库的数据恢复,就是借助于 `redolog` 的两阶段提交,并且先写 `redolog` 再写 `binlog` 的顺序也不能相反; 如果不是两阶段提交,那么要么是先写完 `redolog` 再写 `binlog`; 要么是先写完 `binlog` 再写 `redolog`

假设更新值 `y=2` ,之前旧数据 `y=0`

1. 先写 `redolog` 再写 `binlog`

假设在写完 `redolog` 之后,还没有写入 `binlog` 此时发生宕机

在数据恢复时,`redolog` 里面写入了 `y=2` 的记录,所以恢复后 `y=2` 的记录已经写入完成,但此时 `binlog` 里面并没有 `y=2` 的更新记录. 如果将这份 `binlog` 日志发给其他数据库做备份,那么其他数据库里面就会丢失 `y=2` 的更新,这导致和当前数据库里面的数据不一致

2. 先写 `binlog` 再写 `redolog`

假设在写完 `binlog` 之后,还没有写入 `redolog` 此时发生宕机

由于 `redolog` 里面没有 `y=2` 的日志,所以恢复后的数据库也不会更新这行记录,此时仍然是 `y=0`. 但是 `binlog` 里面已经记录了 `y=2` 的更新,所以将这份 `binlog` 发给其他数据库进行备份的时候,就会多出来一行 `y=2` 的事务,导致和当前数据库里面的数据不一致
