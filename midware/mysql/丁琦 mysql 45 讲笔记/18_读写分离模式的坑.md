## mysql 读写分离场景下的坑

读写分离最常遇到的问题: **由于主从延迟,客户端执行完更新事务后马上查询,如果查询到了还未同步的从库,这时就会得到历史数据**, 这个现象被称作 **过期读**,也就是说在从库上可能会读到一个 **过期的数据**

解决过期读的几种方案如下:

1. 强制查询主库
2. 每次查询前等待若干秒
3. 每次查询前判断是否有主从延迟
4. `semi-sync` 半同步方案
5. 等待主库位点
6. 等待 `GTID`

### 强制查询主库

对于业务有硬性要求更新后的数据必须能够读到,此时只能采取读取主库的方案

这样就牺牲了 **读写分离** 的作用,退化成单节点读写了

### 等待若干秒

如果判断系统的主从延迟大多都在 N 秒以内,那么每次查询前等待 N 秒大概率就能拿到最新数据了

这个方案也有几个问题:

1. 如果设定每次查询前等待 N 秒,而主从延迟下降到 N 秒以内,那么每次查询也必须等待 N 秒
2. 如果主从延迟超过 N 秒,此时还是会发生 **过期读**

### 判断是否存在主从延迟

1. 每次从库查询前,先判断是否存在主从延迟; 如果存在主从延迟就返回等待下一次重试,直到主从延迟为 0 
2. 每次对比主库和从库执行 `binlog` 的位点是否相同
3. 每次对比主库和从库的 `GTID` 集合是否相同

后两种方案都比第一种方案更加准确,但判断主从延迟仍然不可避免 **过期读** 发生

考虑如下场景:

1. 主库已经执行了 `trx1,trx2,trx3` 三个事务,并且 `trx1,trx2` 都已经发送给从库完成了同步
2. 主库在执行完 `trx3` 之后,返回给客户端,但此时还没有传递到从库当中

如果此时在从库上执行查询,从库已经判断没有主从延迟,但这个时候仍然是没法查询到 `trx3` 的修改

### semi-sync 半同步复制

`semi-sync` 半同步复制有以下设计:

1. 事务提交的时候,主库就把 `binlog` 发送给从库
2. 从库收到 `binlog` 之后,回复一个 `ack` 给主库
3. 从库收到 `ack` 之后,才返回客户端 **执行成功**; 而不是在执行完后立即返回

在一主多从结构下, `semi-sync` 半同步复制仍然有可能 **过期** 读:

1. 主库执行完事务后,将 `binlog` 发送给从库 1
2. 从库 1 同步完日志后,回复 `ack` 给主库,然后主库返回客户端执行陈宫
3. 客户端随即发起查询,但是这个查询请求落到了还没来得及同步的从库 2 上,发生 **过期读**

`semi-sync` 机制配合等待主库位点的方案下,如果主从延迟一直存在,会导致从库一致无法更新事务,造成 **过度等待**

### 等待主库位点和等待 GTID 集合

这两个方案都很类似,每次从库查询时,都查询下主库的位点或者 `GTID` 集合

如果通过这两个方案得到主从延迟已经包含了当前更新,那么就执行查询并返回; 否则就从主库上查询返回